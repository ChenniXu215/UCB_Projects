package gitlet;

import java.io.File;
import static gitlet.Utils.*;
import java.io.Serializable;
import java.util.*;
import java.io.IOException;

/** Represents a gitlet repository.
 *  @author Chenni Xu
 */
public class Repository implements Serializable {
    /**
     * List all instance variables of the Repository class here with a useful
     * comment above them describing what that variable represents and how that
     * variable is used. We've provided two examples for you.
     */

    /** The current working directory. */
    public static final File CWD = new File(System.getProperty("user.dir"));
    /** The .gitlet directory. */
    public static final File GITLET_DIR = join(CWD, ".gitlet");
    public static final File REPOSITORY_FILE = join(GITLET_DIR, "repository");
    private static final File BLOB_DIR = join(GITLET_DIR, "blob");
    private HashMap<String, Commit> commitMap; // commit id -> commit object
    private HashMap<String, Commit> branchToHeadMap; // branch name -> branch head
    private HashSet<String> committedBlobs; // blob id -> it is committed
    private String currentHead;
    private String currentBranch;
    // Staging area related
    HashMap<String, String> addMap; // added file -> blob
    HashSet<String> remove; // removed files in the next commit

    private HashMap<String, String> getCurrentFileMap() {
        return commitMap.get(currentHead).getFileMap();
    }

    private void createNewFileSafe(File f) {
        try {
            f.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private String getBlobHash(String fileName, String content) {
        return sha1(fileName, "/", content);
    }

    public void add(String[] args) {
        if (args.length < 2) {
            System.out.println("Not enough parameter for add");
            return;
        }
        String fileName = args[1];
        File blob;
        File userFile = join(CWD, fileName);
        String hashCode, content;
        // Unstaged for removal state
        if (remove.contains(fileName)) {
            remove.remove(fileName);
        }
        if (!userFile.exists()) {
            System.out.println("File does not exist.");
            return;
        }
        // Get the contents and hashcode of the file by its contents.
        content = readContentsAsString(userFile);
        // Hash code of a blob is generated by a string in the following format:
        // [File name]/[File content]
        hashCode = getBlobHash(fileName, content);
        blob = join(BLOB_DIR, hashCode);
        // Create the blob file if it does not exists
        if (!blob.exists()) {
            createNewFileSafe(blob);
            writeContents(blob, content);
        }
        // If the file was in the staging area, delete the old blob
        // if they have different content and the old blob is not
        // used by any commits.
        if (addMap.containsKey(fileName)) {
            String existedBlobHash = addMap.get(fileName);
            File existedBlob = join(BLOB_DIR, existedBlobHash);
            if (!existedBlobHash.equals(hashCode)) {
                if (!committedBlobs.contains(existedBlobHash)) {
                    existedBlob.delete();
                }
                addMap.remove(fileName);
            }
        }
        // If the blob is not in or different from the current head, add
        // the file to the staging area.
        boolean isInCurrCommit = getCurrentFileMap().containsKey(fileName);
        if (isInCurrCommit) {
            String committedFileHash = getCurrentFileMap().get(fileName);
            if (committedFileHash.equals(hashCode)) {
                return;
            }
        }
        addMap.put(fileName, hashCode);
    }

    public void commit(String[] args) {
        // Error handling.
        if (addMap.size() == 0 && remove.size() == 0) {
            System.out.println("No changes added to the commit.");
        }
        if (args.length <= 1 || args[1].length() == 0) {
            System.out.println("Please enter a commit message.");
        }

        // Compare the staging area with the files in the current commit,
        // and build the new commit correspondingly.
        HashMap<String, String> fileMap = new HashMap<>();
        String message = args[1];
        HashMap<String, String> currentFileMap = getCurrentFileMap();
        for (String key : currentFileMap.keySet()) {
            String existedFileName = key;
            String existedFileBlob = currentFileMap.get(key);
            // add the same file to the new commit file map if
            // 1. The file is not in add map.
            // 2. The file is not in remove set.
            if (!addMap.containsKey(existedFileName) && !remove.contains(existedFileBlob)) {
                fileMap.put(existedFileName, existedFileBlob);
            }
        }
        // Add all files in the add map to the new commit map.
        for (String fileName : addMap.keySet()) {
            String blobId = addMap.get(fileName);
            fileMap.put(fileName, blobId);
            committedBlobs.add(blobId);
        }

        // Create the new commit, add it to the commit map, and make it current head.
        Commit newCommit = new Commit(message, fileMap, currentHead);
        String newCommitHash = newCommit.getHash();
        commitMap.put(newCommitHash, newCommit);
        currentHead = newCommitHash;
        branchToHeadMap.put(currentBranch, newCommit);

        // Clean the stage area;
        addMap = new HashMap<>();
        remove = new HashSet<>();
    }

    private String getFullLengthCommitId(String commitId) {
        String fullCommitId = "";
        int numMatchedId = 0;
        for (String longCommitId : commitMap.keySet()) {
            if (longCommitId.substring(0, commitId.length()).equals(commitId)) {
                numMatchedId += 1;
                fullCommitId = longCommitId;
            }
        }
        if (numMatchedId > 1) {
            System.out.println("No commit with that id exists.");
            return "";
        }
        return fullCommitId;
    }

    private void checkoutRecoverFileByCommit(String fileName, String commitId) {
        // Convert shortened commit id to long commit id.
        if (commitId.length() < 40) {
            commitId = getFullLengthCommitId(commitId);
            if (commitId.length() == 0) {
                return;
            }
        }
        if (!commitMap.containsKey(commitId)) {
            System.out.println("No commit with that id exists.");
            return;
        }
        HashMap<String, String> fileMap = commitMap.get(commitId).getFileMap();
        boolean isInCommit = fileMap.containsKey(fileName);
        if (!isInCommit) {
            System.out.println("File does not exist in that commit.");
            return;
        }

        File blob = join(BLOB_DIR, fileMap.get(fileName));
        File workingDirFile = join(CWD, fileName);
        if (!workingDirFile.exists()) {
            createNewFileSafe(workingDirFile);
        }
        writeContents(workingDirFile, readContentsAsString(blob));
    }

    private boolean checkoutRecoverBranch(String branchName, String commitId) {
        // Use branch name to checkout
        if (commitId.length() == 0) {
            if (!branchToHeadMap.containsKey(branchName)) {
                System.out.println("No such branch exists.");
                return false;
            }
            if (branchName.equals(currentBranch)) {
                System.out.println("No need to checkout the current branch.");
                return false;
            }
        }
        Commit checkinCommit;
        if (commitId.length() == 0) {
            checkinCommit = branchToHeadMap.get(branchName);
        } else {
            checkinCommit = commitMap.get(commitId);
        }

        Commit currentCommit = commitMap.get(currentHead);
        // Check if there are any untracked files in the working dir.
        List<String> workingFileNames = plainFilenamesIn(CWD);
        List<String> deleteFileNames = new ArrayList<>();
        for (String fileName : workingFileNames) {
            if (!currentCommit.getFileMap().containsKey(fileName)
                    && !addMap.containsKey(fileName)) {
                System.out.println("There is an untracked file in the way; "
                         + "delete it, or add and commit it first.");
                return false;
            }
            if (!checkinCommit.getFileMap().containsKey(fileName)) {
                deleteFileNames.add(fileName);
            }
        }
        // Recover files
        for (String fileName : checkinCommit.getFileMap().keySet()) {
            File file = join(CWD, fileName);
            if (!file.exists()) {
                createNewFileSafe(file);
            }
            String blobId = checkinCommit.getFileMap().get(fileName);
            File blob = join(BLOB_DIR, blobId);
            writeContents(file, readContentsAsString(blob));
        }
        // Delete non existent files
        for (String fileName : deleteFileNames) {
            File file = join(CWD, fileName);
            file.delete();
        }
        // Clear the staging area
        for (String blobId : addMap.keySet()) {
            if (!committedBlobs.contains(blobId)) {
                File file = new File(CWD, blobId);
                if (!file.exists()) {
                    file.delete();
                }
            }
        }
        addMap = new HashMap<>();
        remove = new HashSet<>();
        // Update the current branch and head;
        if (!branchName.equals("")) {
            currentBranch = branchName;
            currentHead = branchToHeadMap.get(currentBranch).getHash();
        }
        return true;
    }

    public void checkout(String[] args) {
        if (args.length == 3) {
            if (!args[1].equals("--")) {
                System.out.println("Incorrect operands.");
            }
            checkoutRecoverFileByCommit(args[2], currentHead);
        } else if (args.length == 4) {
            if (!args[2].equals("--")) {
                System.out.println("Incorrect operands.");
            }
            checkoutRecoverFileByCommit(args[3], args[1]);
        } else if (args.length == 2) {
            checkoutRecoverBranch(args[1], "");
        } else {
            System.out.println("Invalid parameters.");
        }
    }

    public void log(String[] args) {
        String currCommit = currentHead;
        do {
            System.out.println(commitMap.get(currCommit));
            currCommit = commitMap.get(currCommit).getParent();
        } while (!currCommit.equals("0"));
    }

    public void status() {
        System.out.println("=== Branches ===");
        // Print the rest the of the branches
        Object[] sortedBranchToHeadMap = branchToHeadMap.keySet().toArray();
        Arrays.sort(sortedBranchToHeadMap);
        for (Object branch : sortedBranchToHeadMap) {
            if (branch.equals(currentBranch)) {
                System.out.println("*" + currentBranch);
            } else {
                System.out.println(branch);
            }
        }
        System.out.println();
        System.out.println("=== Staged Files ===");
        Object[] sortedStageFileName = addMap.keySet().toArray();
        Arrays.sort(sortedStageFileName);
        for (Object fileName : sortedStageFileName) {
            System.out.println(fileName);
        }
        System.out.println();
        System.out.println("=== Removed Files ===");
        Object[] sortedRemove = remove.toArray();
        Arrays.sort(sortedRemove);
        for (Object fileName : sortedRemove) {
            System.out.println(fileName);
        }
        System.out.println();
        System.out.println("=== Modifications Not Staged For Commit ===");
        System.out.println();
        System.out.println("=== Untracked Files ===");
    }

    public void branch(String[] args) {
        if (args.length < 2) {
            System.out.println("Not enough paramemter for branch");
            return;
        }
        String branchName = args[1];
        if (branchToHeadMap.containsKey(branchName)) {
            System.out.println("A branch with that name already exists.");
        }
        branchToHeadMap.put(branchName, commitMap.get(currentHead));
    }

    public void rm(String[] args) {
        if (args.length < 2) {
            System.out.println("Not enough paramemters for rm");
        }
        String fileName = args[1];
        boolean isStaged = addMap.containsKey(fileName);
        boolean isInCurrCommit = getCurrentFileMap().containsKey(fileName);
        if (!isStaged && !isInCurrCommit) {
            System.out.println("No reason to remove the file.");
            return;
        }
        // Unstage the file if it is staged
        if (isStaged) {
            String blobId = addMap.get(fileName);
            if (!committedBlobs.contains(blobId)) {
                File blob = Utils.join(BLOB_DIR, blobId);
                blob.delete();
            }
            addMap.remove(fileName);
        }
        // Delete file the in the working dir.
        if (isInCurrCommit) {
            remove.add(fileName);
            File file = Utils.join(CWD, fileName);
            if (file.exists()) {
                file.delete();
            }
        }
    }

    public void globalLog(String[] args) {
        for (Commit c : commitMap.values()) {
            System.out.println(c);
        }
    }

    public void find(String[] args) {
        if (args.length < 2) {
            System.out.println("Not enough paramemters for find");
            return;
        }
        boolean isFound = false;
        String target = args[1];
        for (Commit c : commitMap.values()) {
            if (c.getMessage().equals(target)) {
                System.out.println(c.getHash());
                isFound = true;
            }
        }
        if (!isFound) {
            System.out.println("Found no commit with that message.");
        }
    }

    public void rmBranch(String[] args) {
        if (args.length < 2) {
            System.out.println("Not enough paramemters for rm-branch");
            return;
        }
        String deleteBranch = args[1];
        if (!branchToHeadMap.containsKey(deleteBranch)) {
            System.out.println("A branch with that name does not exist.");
            return;
        }
        if (currentBranch.equals(deleteBranch)) {
            System.out.println("Cannot remove the current branch.");
            return;
        }
        branchToHeadMap.remove(deleteBranch);
    }

    public void reset(String[] args) {
        if (args.length < 2) {
            System.out.println("Not enough paramemters for reset");
            return;
        }
        String checkinCommitId = args[1];
        if (checkinCommitId.length() < 40) {
            checkinCommitId = getFullLengthCommitId(checkinCommitId);
            if (checkinCommitId.length() == 0) {
                return;
            }
        }
        if (!commitMap.containsKey(checkinCommitId)) {
            System.out.println("No commit with that id exists.");
            return;
        }
        if (checkoutRecoverBranch("", checkinCommitId)) {
            currentHead = checkinCommitId;
            branchToHeadMap.put(currentBranch, commitMap.get(currentHead));
        }
    }

    public void merge(String[] args) {

    }


    public Repository() {
        // Initialize maps.
        commitMap = new HashMap<>();
        branchToHeadMap = new HashMap<>();
        addMap = new HashMap<>();
        remove = new HashSet<>();
        committedBlobs = new HashSet<>();
        // Create an initial commit.
        Commit initialCommit = new Commit("initial commit", new HashMap<>(), "0");
        String initialCommitHash = initialCommit.getHash();
        commitMap.put(initialCommitHash, initialCommit);
        currentHead = initialCommitHash;
        currentBranch = "main";
        branchToHeadMap.put(currentBranch, initialCommit);
        // Save this object to a file and created related dir/files.
        try {
            REPOSITORY_FILE.createNewFile();
            BLOB_DIR.mkdir();
        } catch (IOException e) {
            e.printStackTrace();
        }
        writeObject(Repository.REPOSITORY_FILE, this);
    }
}
